- GDT Global Descriptor Table

プロセッサにはいくつかモードが存在する

- リアルモード
    - 仮想メモリのサポートなし
    - 16bit レジスタ幅
    - 物理メモリに直接アクセスする
        - 開始アドレスの取得方法
            - 物理アドレス = (セグメントベース * 16) + オフセット

- 論理アドレス, 物理アドレス
    - 論理アドレスはプログラムから見たメモリの番地 
        - プログラムがMMU(メモリ管理ユニット)に指示する
        - MMUは適当なメモリ番地を選んでメモリにデータを保管する
            - このときプログラムから指示されたメモリ番地とは限らない
        - MMUがメモリにデータを置くときのアドレスを物理アドレスという
        - プログラムがMMUに指示するアドレスを論理アドレスという(実際のメモリ番地ではないことがある)

### プロテクトモード

32bitのものはIntel80386が最初

- 新しいプロテクション機構により、プログラムが互いに隔離され、1つが異常終了しても
他のプログラムに影響を及ばさなくなった
    - プロテクションリング
    - 仮想メモリ
    - セグメンテーションの改善

- 開始アドレスの計算方法
    - リニアアドレス = セグメントベース(システムテーブルから取得) + オフセット
    - 特別なテーブルのエントリをベースとして計算

- セグメントレジスタには`セグメントセレクタ`が格納される
    - セグメントセレクタには`セグメントディスクリプタテーブル`へのインデックスと
    若干の付加情報が含まれる

**セグメントセレクタ**

- 付加情報
    - テーブルインジケータ(1bit)
        - 0: GDT
        - 1: LDT
        - LDTはつかわれていないので常に0
    - RPL: 要求特権レベル(2bit) `Request Privilege Level`
        - 0: 最高
        - 3: 最低
        - RPLがディスクリプタテーブルのDescriptor Privilege Level
        ディスクリプタ特権レベルを満たすかチェックするのに使われる
            - セグメントをセレクタ経由でアクセスするとき



- セグメントディスクリプタテーブル
    - LDT `Local Descriptor Table`
        - テーブル内に多数存在
        - 現在プログラムは仮想メモリによって隔離されている
        - 使われていない
    - GDT `Global Descriptor Table`
        - テーブル内に1つのみ存在
        - GDTR `GDT Register`
            - GDTのアドレスと大きさを格納するレジスタ


プロセッサは常にリアルモードでスタートする
- プロテクトモードに入るには、GDTを作って、gdtrをセットアップ
    - cr0の特別なbitをセット
        - far jumpを行う
            - セグメント or セグメントレジスタを明示的に与えること

### Longモード

- 少なくとも3つのディスクリプタを持つ
    - null descriptor
    - data descriptor
    - code descriptor

### CISC, RISC

- プロセッサのクラス分け(複数ある)
    - 命令の集合(instruction set)に基づく分類
        - CISC Complex Instruction Set Computer
            - 特殊化された高いレベルの命令を数多くつくるもの
            - 実行速度は遅いが多くの仕事をする
        - RISC Reduced Instruction Set Computer
            - 数少ないプリミティブな命令だけを使い、アーキテクチャを作るもの 

Intel64の命令セットは `CISC`

Intel64でeaxを書き換えたときにraxの上位ビットがクリアされるのは
性能を落とさないため

マイクロコードの実行時にデコーダは物理レジスタをたくさん並べたバンクから
そのとき利用できるレジスタを選ぶ

eaxを書き換えてもraxの上位ビットを書き換えていけないとしたら
現在の命令とraxまたはその一部を更新したその前の命令との間に
さらなる依存性が生じる
@Todo あくまで32bitCPUからみた場合(移植性を考えて)
-> でないと32bitCPUから64bitに移るのに苦労する、前述のraxの上位ビット管理の必要があるから
**そのため、上位32ビットを捨てて依存性をなくしている**
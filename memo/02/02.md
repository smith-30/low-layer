## アセンブリ

アセンブリ言語によるプログラミングはCPUと直でやり取りもできるので
そのマシンに積んでるもののアーキテクチャを知っていないといけない

そのため、アセンブリ言語で書かれたプログラムは
**移植性なし**
**維持管理、理解が大変**
**膨大な行数**

ただし、ランタイムバイナリは高速でサイズが小さい
ランタイム -> プログラム実行時に必要なもの
javaでいうJRE(java runtime environment)
-> javaソフトウェアを実行するために必要なソフトウェアパッケージ

### GNU, NASM

GNU Assembler, Netwide Assembler

GNU -> AT&T構文
NASM -> Intel構文

違い等は下記リンク参照
https://www.ibm.com/developerworks/jp/linux/library/l-gas-nasm.html

## ファイル

ここではバイトストリームのこと
プログラムがファイルを開く(openシステムコールを発行)と
**ファイルディスクリプタ**が振られる
stdin, stdout, stderr　順に0, 1, 2だけはプログラム開始即座にオープンされる

### write システムコール

指定アドレスから始まる指定バイト数のメモリを
指定ディスクリプタ(stdoutなら1)の**ファイル**に書き込む

## hello world

hello.asm

コメントはセミコロン

```
; アドレス値の宣言、数ではなくラベルで表現する
; ここでは _start
; ちなみに_startは複数ファイルを使うときのエントリポイントの宣言になる
global _start

; 変数系を宣言
section .data
; dbはバイトデータを作るのに使う
; メッセージはラベル、messageに対応するアドレスを宣言
; 10は改行するときに出力させる特殊文字
message: db 'hello, world!', 10

; 命令系を宣言
section .text
_start:
    mov rax, 1 ; システムコールの番号をraxに入れる
    mov rdi, 1 ; 引数 #1 は rdi: 書き込み先(descripter)
    mov rsi, message ; 引数 #2 は rsi: 文字列の先頭
    mov rdx, 14 ; 引数 #3 は rdx: 書き込むバイト数
    syscall ; システムコールの呼び出し
```

## nasm文法など

.loop など `.` から始まるものはローカルスコープ

角カッコは間接的なアドレッシングを意味する

```
mov rsi, [rax]
```

raxに格納されているアドレスを先頭とするメモリ内容(8個の連続したバイト)が
rsiにコピーされる
rsi, raxともにサイズが8バイトなのでアセンブラが勝手にやってくれる

```
lea rsi, [codes + rax]
```

leaは `実効アドレスをロードせよ`
-> あるメモリセルのアドレスを計算し、そのアドレスをどこかに格納することができる

要は、mov rsi, addrはアドレス数値をコピーし
[addr]は addrを指すアドレスから始まるメモリの内容

lea rsi, [addr] == mov rsi, addr
mov rsi, addr1 + addr2 はできない
lea rsi, [addr1 + addr2] とする


### アドレス指定

- 直接アドレス指定
    - アドレス部の値をそのまま有効アドレスとする

- 関節アドレス指定
    - アドレス部の値でメモリ上のアドレスを指定し
    そのアドレスに格納されている値を有効アドレスとする

### 実行順序

jmp <addr> == mov rip, <addr>

rip is Instruction Pointer Register
ripには次に実行すべき命令のアドレスが格納される
プログラマがアクセス可能

```
    cmp rax, 42
    jl yes
    mov rbx, 0
    kmp ex
yes:
    mov rbx, 1
ex:

```

↑
rax < 42 ならばrdxに1を、そうでなければ0を書く

### 関数

call <address>

下記と同じ

```
push rip
jmp <address>
```

メモリに突っ込んだ番地を指定して動かすのは新鮮。
なかったらnull pointerか。。

関数を実行するとレジスタは内部で変更されるかもしれない。
引数としてrsiやrdxが渡される。
レジスタを守るための **規約** として以下がある

- 呼び出し先退避レジスタ
    - 呼び出されたプロシージャ自身が退避/復旧する
    該当するレジスタを関数内で変更するならその関数で元に戻す
    `callee-saved(呼び出し先退避)`レジスタはレジスタは、
    rbx, rbp rsp, r12-r15の合計7個のレジスタ

- 呼び出し元退避レジスタ
    - 関数を呼び出す側が、**呼び出し前に退避し、呼び出し後に復旧する**
    呼び出し前の値が不要になる場合は退避/復旧の必要はない
    上記7個以外のすべてのレジスタが`caller-saved(呼び出し元退避)`レジスタ
    
呼び出し元退避レジスタを守るためには、値を呼び出し前に保存しておく

### endiann

Intel64はLE
最下位バイトを先頭としてメモリに置かれる

TCP/IPはBE

### 計算

NASMはカッコとビット演算含む算術演算をサポートしている